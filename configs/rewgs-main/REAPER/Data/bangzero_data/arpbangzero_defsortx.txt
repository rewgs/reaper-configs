//arp!0 sort transform: spiral (aka converge/diverge)
//  steps alternate between first/last; 2nd/2nd from last; etc

// name:
//  short sequence of ascii numbers which give a name for the sort 
//  transform.
115,112,105,114,97,108,0 //name: spiral

// steps:
//  specifies how the number of notes generated by a sort transform is
//  calculated from the current number of input notes.  a series of value
//  pairs.  the first value is added to the number of input notes.  the the
//  second value multiplies that sum. these line pairs can repeat.  the last
//  pair ends with a multiplier of zero; which is not used.

0 //plus nothing
0 //times nothing: end - this combination means the transform generates
  //    the same number of notes as the number of input notes.

// prefix:
//  specifies the initial notes generated by the sort transform. positive
//  numbers specify notes from the beginning of the input notes: with one
//  meaning the first; two the second; etc. negative numbers specify notes
//  from the end of the input notes: minus one is last; minus two previous
//  to that; etc. this section ends with a zero value.

1  //abs: first
-1 //abs: last

0  //0: end

// repeat:
//  specifies additional notes after the prefix notes.  this section is
//  calculated repeatedly up to the number of transform notes specified by
//  the steps section.  values can be simple positive and negative numbers
//  that work like the prefix section.  when a value in the repeat section
//  is a zero followed by a negative number; the two values after the zero
//  specify a note relative to previous notes generated by the transform. 
//  the negative value after zero is the number of steps back to the
//  relative value.  the value after that is the offset from the earlier
//  value for this step.  so 0;-2;1 means look two steps back
//  and add one to that value.  this section ends with two zero values.

0,-2,1  //relative to: 2 steps back; offset +1 from that step
0,-2,-1 //rel: back 2; -1

0,0 //2x 0: end

// special rules:
//   a zero followed by a positive number specifies a special rule.  the
//   positive number indicates the type of rule.  following numbers qualify
//   the rule.  currently recognized special rules are:
//
// - 0;1;<probability>;<min step>;<max step>: specifies a random step in 
//   the min/max range entered.  the first value is the probability that the
//   random value will occur.  otherwise the step coming sequentially after
//   the previous one will be generated.  min/max values can be positive or
//   negative for offsets from the start or end of the input notes as in the
//   prefix section.  so 0;1;1;-3;0.5 means a random note from the first to
//   the third from the last; 50% of the time.  the random note is
//   recalculated whenever a new sort transform is loaded; or when the
//   number of input notes changes; or when one of the events in the "update
//   transform on:" section in the arp!0 settings pane is enabled.  these
//   events will create a new sequence of transformed input notes when they
//   occur; including new random steps.
//
// - 0;2;<probability>;<skip count>: skips a number of following rules.
//   the first value is the probability that the skip will occur.  the
//   following number is how many following rules to skip.
//
// - 0;3;<probability>;<value specifier>;<min value>;<max value>;<skip count>
//   the first value is the probability that the conditional skip will occur
//   at all.  next is an integer which specifies a source value.  if
//   negative this is an offset back to a previously generated step which
//   supplies the value.  if zero or higher the value is the current output
//   step number.  note that negative values refer to indices of *input*
//   notes.  but zero and above refer to the index of the current *output*
//   note.  if the integer is greater than zero the min and max values are
//   modified to be relative to a multiple of the count of input notes. 
//   otherwise positive min/max are relative to the first input step and
//   negative relative to the last input step as in the relative value
//   rules.  the final value is how many following rules to skip if the
//   specified value is greater than or equal to the minimum and less than
//   or equal to the maximum values.  ...fwiw all this may seem pretty
//   magical.  there was a comment at one point in the original unix source
//   code to the effect that "you probably won't understand this.  just know
//   that it works."  if this too brief explaination is beyond understanding
//   please know that this rule makes some very cool sort transforms
//   possible.  or contact the author who is happy to help.  :^)

// ps- semicolons used instead of commas because Js parses another number
//   after every comma

//______________________________________________________________________________
//arp!0 sort transform: bounce down (aka thumb)
//  repeat first step between other steps in sequence

//name:
98,111,117,110,99,101,100,111,119,110,0 //name: bouncedown

//steps: 

-1 //+
2 //*
0 //+
0 //*0: end

//prefix:

1 //abs: first
2 //abs: second
0 //0: end

//repeat:

1 //abs: first
0,-2,1 //relative to 2 steps back offset +1

0 //2x 0: end
0

//______________________________________________________________________________
//arp!0 sort transform: bounce up (aka pinky)
//  repeat last step between other steps in sequence

98,111,117,110,99,101,117,112,0 //name: bounceup

//steps: 

-1 //+
2  //*
0  //+
0  //*0: end

//prefix:

1  //abs: first
-1 //abs: last
0  //end

//repeat

0,-2,1  //relative to 2 steps back offset +1 from that step
-1 //abs: last

0  //end
0

//______________________________________________________________________________
//arp!0 sort transform: tripdown
//  repeat first step between random other steps

//name:
116,114,105,112,100,111,119,110,0 //name: tripdown

//steps:

-1 //+
2 //*
0 //+
0 //*0: end

//prefix:

0 //0: end prefix

//repeat:

1 //first
0,1,1,2,-1 // random step: always; 2nd to last
0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: trip up
//  repeat last step between random other steps

116,114,105,112,117,112,0 //name: tripup

//steps: 

-1 //+
2  //*
0  //+
0  //*0: end

//prefix:

0  //end

//repeat

0,1,1,1,-2 // random step: always; 1st to 2nd from last
-1 //abs: last

0  //end
0

//______________________________________________________________________________
//arp!0 sort transform: fall down
//  repeat first step 50% of the time between other steps in sequence

//name:
102,97,108,108,100,111,119,110,0 //name: falldown

//steps:

0
1.5 //1.5x len
0 //+0
0 //*0: end steps

//prefix:

0 //0: end prefix

//repeat:

0,2,.5,1 //50% prob skip 1
1 //first
// if prev step is 1st look back two steps
0,3,1,-1,1,1,3 //skip to 2nd prev
// if prev step is last loop back to 2nd step
0,3,1,-1,-1,-1,5 //skip to 2nd step
// if prev step neither 1st or last do normal next step
0,-1,1 //prev+1: next
0,2,1,4 //to end
// 2nd prev step
// if 2nd prev step is last loop back to 2nd step
0,3,1,-2,-1,-1,2 //skip to 2nd step
// do next step from 2 steps prev
0,-2,1 //(2nd prev)+1
0,2,1,1 //to end
//2nd step
2

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: fall up
//  repeat last step 50% of the time between other steps in sequence

//name:
102,97,108,108,117,112,0 //name: fallup

//steps:

0
1.5 //1.5x len
0 //+0
0 //*0: end steps

//prefix:

0 //0: end prefix

//repeat:

0,2,.5,1 //50% prob skip 1
-1 //last
// if prev step is last look back two steps
0,3,1,-1,-1,-1,3 //skip to 2nd prev
// if prev step 2nd from last loop back to 1st step
0,3,1,-1,-2,-2,5 //skip to 1st step
// if prev step neither last or 2nd from last do normal next step
0,-1,1 //prev+1: next
0,2,1,4 //to end
// 2nd prev step
// if 2nd prev step 2nd from last loop back to 1st step
0,3,1,-2,-2,-2,2 //skip to 1st step
// do next step from 2 steps prev
0,-2,1 //(2nd prev)+1
0,2,1,1 //to end
//1st step
1

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: progress (2 steps forward; one step back)
//  needs at least 4 notes to work right

//name:
112,114,111,103,114,101,115,115,0 //name: progress

//steps: 

-4 //+
2 //*
4 //+
0 //*0: end

//prefix:

1  //abs: 1st
3  //abs: 3rd
0  //0: end

//repeat:

0,-2,1 //2 steps back +1

0  //2x 0: end
0

//______________________________________________________________________________
//arp!0 sort transform: doubler
//  each step repeats once followed by next step repeated once etc

//name:
100,111,117,98,108,101,114,0 //name: doubler

//steps: 

0  //+
2  //*
0  //+
0  //*0: end

//prefix:

1  //1st
0  //0: end

//repeat

0,-1,0  //rel back 1 +0
0,-1,1  //rel back 1 +1

0  //2x 0: end
0

//______________________________________________________________________________
//arp!0 sort transform: final 4
//  last 4 steps repeat sequentially

//name:
102,105,110,97,108,52,0 //name: final4

//steps:

0 //+0
0.0001 //* ~0
4 //+ 4 - final count truncated to 4
0 //*0: end steps

//prefix:

-4
-3
-2
-1 //eq last
0 //0: end prefix

//repeat:

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: random triads
//  every 3rd step random followed by 2 sequential steps

//name:
114,97,110,100,116,114,105,115,0 //name: randtris

//steps:

0 //+0
0 //*0: end steps

//prefix:

0 //0: end prefix

//repeat:
0,1,.5,1,-3 //0;1: random step; .5: 50%prob; 1;-3: 1st to 3rd from last; -3 to avoid wraparound triads
0,-1,1
0,-1,1

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: 1/4to1
//  25% probability to restart at first step; otherwise sequential
//  step cycle restarts about every 4th step

//name:
49,47,52,116,111,49,0 //name: 1/4to1

//steps:

0 //+0
0 //*0: end steps

//prefix:

0 //0: end prefix

//repeat:

0,2,.75,2 //75% prob skip 2
1
0,2,1,1 //skip 1
0,-1,1

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: random start
//  random 1st step; then other steps sequential til next cycle

//name:
114,97,110,100,115,116,97,114,116,0 //name: randstart

//steps:

0 //+0
0 //*0: end steps

//prefix:

0 //0: end prefix

//repeat:

0,3,1,0,1,1,2 //skip if cur step is first
0,-1,1 //24
0,2,1,1
0,1,1,1,-1 //rand

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: 8 step pattern from 1st 4 notes

//name:
119,97,108,107,101,101,122,0 //name: walkeez

//steps:

0 //+0
0.0001 //*~0: fixed length
8 //+0
0 //*0: end steps

//prefix:

1,2,4,2,3,4,3,2

0 //0: end prefix

//repeat:

0,0 //2x 0: end repeat

//______________________________________________________________________________
//arp!0 sort transform: ssergorp (2 steps back; one step forward)
//  needs at least 4 notes to work right

//name:
115,115,101,114,103,111,114,112,0 //name: ssergorp

//steps: 
-4,2,4,0

//prefix:
-1,-3,0

//repeat:
0,-2,-1 //2 steps back -1
0,0

//______________________________________________________________________________
//null sortx

110,117,108,108,0 //name: null

//steps
0,0

//prefix
1
0

//repeat
0,-1,1 //next
0,0 //end

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________

//______________________________________________________________________________
