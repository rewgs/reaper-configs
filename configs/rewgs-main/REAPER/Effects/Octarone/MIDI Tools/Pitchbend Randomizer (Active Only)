// Written by octarone, licensed under GPL, see License.txt or visit <http://www.gnu.org/licenses/>

desc: Pitchbend Randomizer (Active Only)
in_pin:none
out_pin:none
slider1:4<2,16,1>Channels
slider2:100<1,1000,0.00001>Message Frequency (Hz)
slider3:-1<-1,1,0.00001>Lower Value
slider4:1<-1,1,0.00001>Upper Value
slider5:1000<1,10000,0.00001>Change Duration (ms)



@init
channels = 0;



@slider
channels!==slider1 ? (
  channels = (slider1=min(max(slider1|0, 2), 16));  msg_mid = slider1/2 + 223.5;  msg_rng = (slider1+1)/2;

  // order = 0;  // stuff[0] will be order
  back = slider1;
  bend = slider1*2;
  prev = slider1*3;
  co = slider1*4;
  list = slider1*5;
  notes= slider1*6;
  cv = slider1*7;
  cw = slider1*8;
  ct = slider1*9;

  memset(bend, 8192, slider1*2);
  memset(co, 0, slider1*6);

  active = 0; step = 1;
);
slider3 = min(max(slider3, -1), 1);
slider4 = min(max(slider4, slider3), 1);
slider5 = max(slider5, 1);
slider2 = max(max(slider2, 1000/slider5), 1);

range = (slider4 - slider3)*8192;  hrange = range/2;
lower = slider3*8192;
ticks = srate/slider2;
iticks = slider2/srate;  iticks1 = 1-iticks;
steps = (slider2*slider5)/1000;  steps1 = steps+1;

i = first;  step *= steps;  a = 1/step;  b = sqr(a);
loop(active,
  co[i] *= step;  cw[i] *= a;  ct[i] *= b;
  i = i[0];  // next
);
step = 1/steps;
step_q = sqr(step);
stepC = step*0.75;
rstep = range*step;
rstep_q = range*step_q;



@block
q = 0;
while(
 ((d = midirecv(o,a,b,c))===0 ? (o = samplesblock; 1)) || q < o ? (
  i = first;
  loop(active,
   k = list[i];
   o > k ? (
    v = cv[i]+(j = bend[i]);  w = cw[i];  t = ct[i];  x = co[i];
    p = prev[i];  y = lower+j;  h = i + $xE0;

    l = (o - k)*iticks+iticks1 |0;
    while(l > (n = steps1-x |0)) (
     n > 0 ? (
      l -= n;  x += n;
      loop(n,
       (n = min(max(v, 0), 16383)|0) !== p ? (
        p = n; midisend(k, h, n + (n & $x3F80));
       );
       v += w; w += t; k += ticks;
      );
     );
     x -= steps;  n = x*t;  v -= (w - (n+t)/2)*x;  w -= n;  n = t;
     t = (rand(1)*range + y - v)*step_q + (t - w*2)*stepC;
     w += (t-n)/2;  n = x*t;  v += ((n-t)/2 + w)*x;  w += n;
    );
    x += l;
    loop(l,
     (n = min(max(v, 0), 16383)|0) !== p ? (
      p = n; midisend(k, h, n + (n & $x3F80));
     );
     v += w; w += t; k += ticks;
    );
    prev[i] = p;  list[i] = k;
    cv[i] = v-j;  cw[i] = w;  ct[i] = t;  co[i] = x;
   );
   i = i[0];
  );

  q = o;
 );

 d ? (
  abs(a-msg_mid) < msg_rng ? (
   bend[(a -= $xE0)] = b + c*128;
   o < (k=(l=list+a)[0]) ? (
    t = ct[a];  c = (o - k)*iticks;  l[0] = o;  co[a] += c;  w = cw+a;
    b = c*t;  cv[a] += ((b-t)/2 + w[0])*c;  w[0] += b;
   );
  ) : (
   midisend(o, a, b, c);
   a < $xA0 ? (
    a < $x90 ? (
     (a-=$x80) < slider1 && (c = ((b = notes+a)[0]-=1)) <= 0 ? (
      c < 0 ? (b[0] = 0) : (
       a===last ? (last = back[a]) : (a===first ? (first = a[0]) : ((b=back[a])[0] = (c=a[0]); back[c] = b));
       active -= 1;
      );
     );
    ) : (a-=$x90) < slider1 ? (
     (notes[a] += 1)===1 ? (
      (active ? (back[a] = last; last[0]) : first) = a;
      last = a;  active += 1;

      b = rand(1); c = rand(1); co[a] = (x = rand(1)*steps);
      t = (rand(1) + b - c*2)*rstep_q;  ct[a] = t;
      w = (c - b)*rstep + t/2;  v = x*t;
      cv[a] = (c + b)*hrange + ((v-t)/2 + w)*x + lower;
      cw[a] = w + v;  list[a] = o;

     ) : o < (k=(l=list+a)[0]) ? (
      t = ct[a];  c = (o - k)*iticks;  l[0] = o;  co[a] += c;  w = cw+a;
      b = c*t;  cv[a] += ((b-t)/2 + w[0])*c;  w[0] += b;
     );
    );
   );
  );
  1
 );
);
i = first; loop(active, list[i] -= samplesblock; i = i[0]);